<!DOCTYPE HTML>
<html lang="de" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tutorials</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Startseite</a></li><li class="chapter-item expanded affix "><li class="part-title">Informatik</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Java</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="informatik/java/java-basics.html"><strong aria-hidden="true">1.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="informatik/java/schleifen.html"><strong aria-hidden="true">1.2.</strong> Schleifen</a></li><li class="chapter-item expanded "><a href="informatik/java/klassenbeziehungen.html"><strong aria-hidden="true">1.3.</strong> Klassenbeziehungen</a></li><li class="chapter-item expanded "><a href="informatik/java/abstrakte-klassen.html"><strong aria-hidden="true">1.4.</strong> Abstrakte Klassen 2</a></li><li class="chapter-item expanded "><a href="informatik/java/generalisierung.html"><strong aria-hidden="true">1.5.</strong> Generalisierung 2</a></li><li class="chapter-item expanded "><a href="informatik/java/definitionen.html"><strong aria-hidden="true">1.6.</strong> Definitionen</a></li><li class="chapter-item expanded "><a href="informatik/java/arrays.html"><strong aria-hidden="true">1.7.</strong> Arrays</a></li></ol></li><li class="chapter-item expanded "><a href="informatik/lexikon.html"><strong aria-hidden="true">2.</strong> Lexikon</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tutorials</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/14-U1/tutorials/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="java-basics"><a class="header" href="#java-basics">Java Basics</a></h1>
<p>Auf diesen Seiten habe ich nochmal kleine Erklärungen zu allen Themen geschrieben.<br>
Vielleicht hilft euch ja nochmal eine alternative Erklärung.<br></p>
<blockquote>
<p><strong>Ich möchte niemanden weiter verwirren und hier können auch Falschinformationen dabei sein. Nutzten zum Lernen auf eigene Gefahr! Das ist keine Alternative zum Lernen :P</strong></p>
</blockquote>
<p>Viel Spaß beim Java lernen, falls ihr Fragen habt, schreibt uns einfach an<br>
~ Flo :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-basics-1"><a class="header" href="#java-basics-1">Java Basics</a></h1>
<ol>
<li><a href="informatik/java/java-basics.html#attribute">Attribute</a></li>
<li><a href="informatik/java/java-basics.html#methoden">Methoden</a></li>
<li><a href="informatik/java/java-basics.html#objekt-orientierung-und-zugriffsmodifikatoren">OOP und Klassen</a></li>
</ol>
<h2 id="attribute"><a class="header" href="#attribute">Attribute</a></h2>
<p>In Java können wir durch Attribute Werte in dem RAM abspeichern und darauf zugreifen.
Hier sind einige Beispiele, wie man Attribute deklariert:</p>
<pre><code class="language-java">String name;
int alter;
double literWasser;
</code></pre>
<p>Wie man im Beispiel sehen kann, werden Attribute mit <code>Datentyp + name + ;</code> deklariert.
Diesen Attributen wurden Standardwerte zugeordnet (siehe <a href="informatik/java/./arrays.html#standardwerte">Standardwerte</a>).
Um Attributen neue Werte zu geben, benutzt man den Zuweisungsoperator.
Dem Attribut links wird der Wert rechts zugeswiesen:</p>
<pre><code class="language-java">name = &quot;Florian&quot;;
alter = 16;
literWasser = 5.2;
</code></pre>
<p>Man kann die Attribute auch direkt bei der Deklaration initialisieren, was für erhöhte
Lesbarkeit sorgt:</p>
<pre><code class="language-java">String name = &quot;Florian&quot;;
int alter = 16;
double literWasser = 5.2;
</code></pre>
<p>Der Name eines Attributes kann sich nicht ändern.</p>
<h2 id="methoden"><a class="header" href="#methoden">Methoden</a></h2>
<p>Klassen können neben Attributen, Methoden enthalten.
Methoden sind Codestücke, die von anderen Methoden aus aufgerufen werden können.
Beim Aufrufen einer Methode können wir ihr auch Werte übergeben:</p>
<pre><code class="language-java">private int addieren(int a, int b) {
    int c = a + b;
    return c;
}
</code></pre>
<p>Jede Methode hat eine Methodensignatur.
Diese besteht aus der ersten Zeile der Methode, in welcher Zugriffsmodifikatoren,
Rückgabetyp, Name der Methode und Parameter angegeben werden.
Darunter ist der Methodenrumpf (alles in den geschweiften Klammern), welcher den Code
enthält, der beim Aufrufen der Methode ausgeführt wird.</p>
<p>Die Beispielmethode oben nimmt 2 Integer Werte an und gibt einen Integerwert zurück.
Sie kann mit <code>addieren(1, 2)</code> von der gleichen Klasse aus aufgerufen werden.
Falls das Ergebnis gespeichert werden soll, muss es einer Variable oder einem Attribut
zugewiesen werden: <code>int summe = objekt.addieren(1, 2)</code> (siehe <a href="informatik/java/java-basics.html#attribute">Attribute</a>).</p>
<p>Bei manchen Methoden gibt es kein Ergebnis, also geben sie nichts zurück.
Diese haben dann <code>void</code> als Rückgabetyp.
Beispielsweise die Main Methode <code>public static void main(String[] args) {}</code> gibt nichts
zurück.</p>
<p>Eine Methode ist immer Teil einer Klasse.
Die Zugriffsmodifikator bestimmt die Sichtbarkeit.
Zugriffsmodifikatoren werden im Nächsten Abschnitt
<a href="informatik/java/java-basics.html#objekt-orientierung-und-zugriffsmodifikatoren">OOP und Zugriffsmodifikatoren</a> erklärt.</p>
<h2 id="objekt-orientierung-und-zugriffsmodifikatoren"><a class="header" href="#objekt-orientierung-und-zugriffsmodifikatoren">Objekt Orientierung und Zugriffsmodifikatoren</a></h2>
<p>Nachdem Attribute und Methoden verstanden sind, sind Klassen an der Reihe.
Der Datentyp <code>String</code> ist zum Beispiel eine Klasse.
Klassen werden <strong>immer</strong> großgeschrieben.
So wird zum Beispiel <code>String</code> großgeschrieben und <code>int</code> klein, weil <code>int</code> ein primitiver
Datentyp ist.
Klassen sind Behälter für Attribute und Methoden.
Ein Objekt ist eine Ausprägung einer Klasse mit Attributwerten.
Eine Klasse ist ein Weg, Attribute und Methoden zu bündeln und abzukapseln.
Das bündeln kann die Programmierung vereinfachen und übersichtlicher machen.
Hier eine Beispielklasse &quot;Konto&quot;:</p>
<pre><code class="language-java">class Konto {
    private int kontoNummer;
    private String name;

    public Konto(int kontoNummer, String name) {
        this.kontoNummer = kontoNummer;
        this.name = name;
    }

    public int getKontonummer() {
        return this.kontonummer;
    }
}
</code></pre>
<p>Hier kommt auch das Prinzip von &quot;Sichtbarkeit&quot; ins Spiel.
Die Attribute &quot;kontoNummer&quot; und &quot;name&quot; sind <code>private</code>.
Das heißt, sie sind nur in dieser Klasse sichtbar.
Nicht außerhalb unseres &quot;Bündels&quot;
Unter den Attributwerten ist ein Beispiel Konstruktor.
Ein Konstruktor ist einfach eine besondere Methode, die wir nutzen, um unser Objekt zu erstellen.
Momentan ist unsere Klasse einfach ein Plan.
Der Konstruktor erstellt ein Objekt, wo alle Attributwerte und Methoden drin sind.</p>
<blockquote>
<p>In die Objekte können wir nicht reingucken, nur in die Klassen!</p>
</blockquote>
<p>Danach kommt eine &quot;getMethode&quot; das ist eine einfache Methode, die einen privaten Wert zurückgibt. Diese ist <code>public</code>, da wir sie außerhalb unseres Objektes nutzen wollen.
Hier ein Beispiel, wo ich ein Objekt namens konto1 erstelle und danach benutzte:</p>
<pre><code class="language-java">Konto konto1 = new Konto(1, &quot;Florian&quot;);
konto1.getKontonummer() //rückgabe: 1
</code></pre>
<p>Der Konstruktor wird mit <code>new KLASSENNAME();</code> aufgerufen.
Hierbei ist zu beachten, dass wir das Konto genau wie einen normalen String oder integer
abspeichern. (<code>String name = &quot;Florian&quot;</code>).
Hier ist auch zu sehen, das wir die public Methode &quot;getKontonummer&quot; über einen Punkt
aufrufen.
Das Objekt <code>konto1</code> ist unser Bündel, wir haben nur noch Zugriff auf die <code>public</code>
Attribute und Methoden.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schleifen"><a class="header" href="#schleifen">Schleifen</a></h1>
<ol>
<li><a href="informatik/java/schleifen.html#if-else">if else</a></li>
<li><a href="informatik/java/schleifen.html#for-loops">for loops</a></li>
<li><a href="informatik/java/schleifen.html#while-schleifen">while schleifen</a></li>
<li><a href="informatik/java/schleifen.html#do-while-schleifen">do while schleifen</a></li>
<li><a href="informatik/java/schleifen.html#scanner">scanner</a></li>
</ol>
<h2 id="if-else"><a class="header" href="#if-else">if else</a></h2>
<p>Falls wir code schreiben wollen, der von einer Bedingung abhängig ist, nutzten wir <code>if</code> und <code>else</code></p>
<pre><code class="language-java">boolean test = true;
if (test) {
    System.out.println(&quot;&lt;test&gt; ist true!&quot;);
} else {
    System.out.println(&quot;&lt;test&gt; ist false!&quot;);
}
</code></pre>
<p>In der ersten Zeile sehen wir nach <code>if</code> direkt die Bedingung in Klammern. Hier, der boolean &quot;test&quot;. Auch hier wird alles in geschwungenen Klassen ausgeführt. Bei dem Beispiel oben ist auch &quot;else&quot; zu sehen. Das wird ausgeführt, falls die erste Bedingung nicht wahr ist, (false), dann wird else ausgeführt.</p>
<blockquote>
<p>Wichtig: else ist optional. Wir können auch nur eine <code>if</code> Bedingung haben. If kann alleine stehen, aber <strong>else steht niemals ohne if davor!</strong></p>
</blockquote>
<p>Wir können auch mehrere Bedingungen aneinander reihen:</p>
<pre><code class="language-java">int kekse = 2;

if (kekse == 0) {
    System.out.println(&quot;keine Kekse mehr da :(&quot;);

} else if (kekse == 1) {
    System.out.println(&quot;Ein Keks ist noch da! :)&quot;);

} else {
    System.out.println(&quot;Genug Kekse für mich! :&gt;&quot;);
}
</code></pre>
<p>Hier benutzte ich einfach <code>else if (Bedingung)</code>.</p>
<h2 id="for-loops"><a class="header" href="#for-loops">for loops</a></h2>
<p>wenn wir eine Aktion x-mal ausführen wollen, benutzten wir eine for Schleife.</p>
<pre><code class="language-java">for (int i = 0; i &lt; x; i++) {
    System.out.println(i); // 0, 1, 2, 3 ... x-1
}
</code></pre>
<p>In der ersten Zeile der <code>for</code> Schleife ist die Bedingung <code>(int i = 0; i &lt; x; i++)</code> zu sehen. Hier passieren 3 Sachen:</p>
<ol>
<li>Wir erstellen eine <strong>Laufvariable</strong> i mit <code>int i = 0;</code></li>
<li>wir überprüfen, ob i kleiner ist als x (unsere Stopp-zahl. z.B. 10) mit <code>i &lt; x;</code> </li>
<li>Falls die Bedingung in Schritt 2 wahr ist (<code>i &lt; x</code>) wird alles in den
geschwungenen Klammern ausgeführt (hier: <code>System.out.println(i);</code>). Danach wird 1
zu i mit <code>i++</code> addiert und die Schleife springt zu Schritt 2. Falls die Bedingung
in Schritt 2 falsch ist, wird die Schleife abgebrochen.</li>
</ol>
<h2 id="while-schleifen"><a class="header" href="#while-schleifen">While schleifen</a></h2>
<p>While schleifen nutzen wir, wenn wir etwas so lange ausführen wollen, bis eine Bedingung wahr ist.</p>
<pre><code class="language-java">boolean hunger = true;
while(hunger) {
    essen();
}
</code></pre>
<p>Die Methode <code>essen()</code> wird so lange aufgerufen, bis hunger <code>false</code> ist.</p>
<blockquote>
<p>Wichtig: While schleifen können unendlich laufen, wenn man nicht aufpasst. z.B., wenn die Bedingung <code>true</code> ist und sich nie ändert.</p>
</blockquote>
<p>Mehr Informationen ist in unserer Präsentation auf Teams.</p>
<h2 id="do-while-schleifen"><a class="header" href="#do-while-schleifen">do while Schleifen</a></h2>
<p>do while Schleifen sind ähnlich wie <a href="informatik/java/schleifen.html#while-schleifen">while Schleifen</a>, aber der code wird erst ausgeführt, und <em>danach</em> die Bedingung überprüft:</p>
<pre><code class="language-java">boolean hunger = false;
do {
    essen(); // &quot;essen&quot; wird mindestens 1 mal ausgeführt, auch wenn hunger == false ist.
} while (hunger);
</code></pre>
<h2 id="scanner"><a class="header" href="#scanner">Scanner</a></h2>
<p>der Scanner ist eine Klasse, die benutzt werden kann, um Daten vom User einzulesen. Dabei müssen wir erst das Objekt erstellen.</p>
<pre><code class="language-java">Scanner eingabe = new Scanner(System.in);
</code></pre>
<blockquote>
<p>Für die Arbeit am Montag müssen wir <strong>nicht</strong> ein Scanner Objekt erstellen können. Uns wird das Scanner-Objekt zur Verfügung gestellt. (hier: <code>eingabe</code>)</p>
</blockquote>
<pre><code class="language-java">private String username = scanner.nextLine();
private int alter = scanner.nextInt();
scanner.nextLine(); // muss hier stehen, da nach nextInt(); nicht der Buffer gelöscht wird.
private String lieblingsfarbe = scanner.nextLine();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="klassenbeziehungen"><a class="header" href="#klassenbeziehungen">Klassenbeziehungen</a></h1>
<p>die folgenden Beispielklassen wurden nur vereinfacht implementiert. Echte Klassen haben weitere Attribute, andere Zugriffsmodifikator und Konstruktoren. Auch Namen ändern sich.
Hier ist eine gute quelle, <a href="https://www.informatik.uni-leipzig.de/~stjaenicke/mup1/s2.pdf">Klassenbeziehungen uni-Leipzig</a></p>
<h2 id="aggregation"><a class="header" href="#aggregation">Aggregation</a></h2>
<p>bei einer Aggregation existieren beide Klassen unabhängig, eine ist jedoch teil der anderen.
Das Kann in Java so implementiert werden. Hier wird ein Auto als Hauptklasse (dem Ganzen) und eine &quot;Reifen&quot; Klasse als teil Klasse benutzt:</p>
<pre><code class="language-java">class Reifen {

}

class Auto {
    private Reifen r1;
    
    public Auto(Reifen reifen) {
        this.r1 = reifen;
    }
}
</code></pre>
<p>Im Konstruktor des Autos wird der Reifen übergeben. Der Reifen existiert außerhalb des Autos, ist aber Teil von diesem.
Die Autoklasse kann so instanziiert werden: <code>new Auto(einReifenObjekt);</code> </p>
<h2 id="komposition"><a class="header" href="#komposition">Komposition</a></h2>
<p>die Komposition ist eine &quot;verstärkte&quot; Aggregation. Hier ist die teil Klasse fester Bestandteil der Hauptklasse. (dem Ganzen)
hier zum Beispiel ein Haus als ganzes und ein Raum als teil. Der Raum kann nicht ohne Haus existieren.</p>
<pre><code class="language-java">class Raum {

}

class Haus {
    private Raum raum;

    public Haus() {
        this.raum = new Raum();
    }
}
</code></pre>
<p>Das Raum-Objekt wird innerhalb des Konstruktors der Haus-Klasse erzeugt. So muss kein Objekt übergeben werden, und jedes Haus erstellt automatisch ein Raum. Ein Haus kann instanziiert werden durch dem Konstruktor: <code>new Haus();</code>.</p>
<h1 id="generalisierung-und-spezialisierung"><a class="header" href="#generalisierung-und-spezialisierung">Generalisierung und Spezialisierung</a></h1>
<p>Generalisierung und Spezialisierung sind 2 Wege, um Klassen zu vereinfachen.
Beispielsweise haben wir eine <code>Küche</code> Klasse und eine <code>Wohnzimmer</code> Klasse.<br>
Beides sind Klassen, die wir Zusammenfassen könnten. Schließlich sind ja beides Räume.<br>
So könnte eine &quot;Raum&quot; Klasse aussehen:</p>
<pre><code class="language-java">class Raum {
    boolean fenster;
    int tueren;
}
</code></pre>
<p>Bisher noch nichts Neues.<br>
Wir wollen aber nicht, das ein &quot;Raum&quot; Objekt erstellt werden kann. Diese Klasse soll ja nur als Vereinfachung der Unterklassen [<code>Kueche</code> und <code>Wohnzimmer</code>] dienen. Deshalb machen wir die Klasse <code>abstract</code>.</p>
<pre><code class="language-java">abstract class Raum {...}
</code></pre>
<p>Jetzt haben wir eine abstrakte Klasse um Räume darzustellen. Bisher haben wir aber noch gar nichts mit unseren Unterklassen gemacht. Wir müssen dem Java Compiler sagen, das die <code>Kueche</code> und <code>Wohnzimmer</code> Klassen die &quot;Raum&quot; Klasse erweitern. Das geht mit dem <code>extends</code> Modifikator:</p>
<pre><code class="language-java">class Kueche extends Raum {...}
class Wohnzimmer extends Raum {...}
</code></pre>
<p>Das war die Generalisierung. Wir haben 2 Unterklassen und vereinfachen die in einer Oberklasse. Generalisierung und Spezialisierung sind das Gleiche. Nur aus einer anderen Sicht. Bei der Spezialisierung hätten wir eine Oberklasse und wollen die &quot;spezialisieren&quot;. Es ist genau der gleiche code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstrakte-klassen"><a class="header" href="#abstrakte-klassen">Abstrakte Klassen</a></h1>
<p>wir können eine Klasse den <code>abstract</code> Modifizierer geben, damit kein Objekt von ihr erstellt werden kann. Stellt euch eine abstrakte Klasse wie eine Art &quot;Vorlage Klasse&quot; vor. Eine andere Klasse kann mit <code>extends</code> von der abstrakten Klasse abstammen (mehr dazu in &quot;Klassenbeziehungen&quot;). Dabei können wir einen Konstruktor mittels <code>super()</code> aufrufen, auf <code>protected</code> Attributen zugreifen und Methoden überschreiben. Hier ist ein Beispiel:</p>
<pre><code class="language-java">public abstract class VorlageKlasse {

    protected int testInt;
    public abstract void testVoid();
    
    public VorlageKlasse(int testInt) {
        this.testInt = testInt;
    }
}
</code></pre>
<blockquote>
<p>Das ist das komplizierteste, was wir machen müssen. Viele Sachen, die hier vorkommen, wurden in anderen Beiträgen erklärt. Es macht also Sinn, mindestens die folgenden: <a href="informatik/java/./Definitionen.html">Definitionen</a>, <a href="informatik/java/./Generalisierung.html">Generalisierung 2</a> und <a href="informatik/java/./klassenbeziehungen.html">Klassenbeziehungen</a> erstmal durchzulesen.</p>
</blockquote>
<p>In der ersten Zeile sehen wir <code>abstract class VorlageKlasse {</code> hiermit deklarieren wir eine neue abstrakte Klasse namens <code>VorlageKlasse</code>.<br><br>
In der nächsten Zeile sehen wir einen <code>protected</code> integer namens testInt. <code>protected</code> ist ähnlich wie <code>private</code>. Das heißt, wenn eine Klasse unserer VorlageKlasse abstammt, hat diese Klasse (und ihr Objekt) zugriff auf diesen Integer. Von außen, kann man den Integer aber nicht erreichen. Das sieht man gleich am Beispiel am besten. Dazu könnt ihr mit NetBeans / IntelliJ-Idea etwas herumspielen. So bekommt man dafür ein Gefühl.<br><br>
Nach dem protected integer, kommt <code>abstract void testVoid();</code>. Das ist eine abstrakte Methode. Besser gesagt, es ist die Signatur der abstrakten Methode. <strong>Abstrakte Methoden haben keinen Methodenrumpf</strong> wie normale <a href="informatik/java/./java-basics.html">Methoden</a>. Das ist so, weil diese Methode von unserer abstammenden Klasse implementiert werden soll. Wie bereits gesagt ist unsere abstrakte Klasse nicht mehr als eine &quot;Vorlage&quot;. Das Gleiche gilt für diese Methode. Sie ist eine Vorlage. Wie die implementiert werden soll, sieht man gleich im Beispiel.<br><br>
Nach unseren Attributen kommt noch unser Konstruktor. Der dürfte allen bekannt vorkommen. Hier hat sich nichts geändert. Da wir aber kein Objekt von einer abstrakten Klasse erstellen können, wird dieser mithilfe von <code>super()</code> in unserer abstammenden Klasse ausgeführt.<br><br>
Hier ist ein Beispiel, wie eine abstammende Klasse aussehen könnte;</p>
<pre><code class="language-java">public class abstammendeKlasse extends VorlageKlasse { //normale Klasse stammt der abstrakten VorlageKlasse ab.
    
    private String testString; //normales Attribut
    
    public abstammendeKlasse(int testInt, String testString){ //normaler Konstruktor der abstammendeKlasse
        super(testInt); //wir rufen den Konstruktor der Oberklasse &quot;VorlageKlasse&quot; auf
        this.testString = testString;
    }

    public void testVoid() { //Diese Methode ist die implementation der abstrakten Methode in VorlageKlasse. Diese hier MUSS implementiert werden!
        //beispiel leere Methode
    }

    public int getTestInt() { //getter für den protected wert der VorlageKlasse
        return this.testInt;  //wir haben in der abstammendeKlasse nirgendswo testInt deklariert. Wir können auf ihn trotzdem zugreifen, da er in der Oberklasse &quot;VorlageKlasse&quot; als protected deklariert wurde.
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generalisierung-und-spezialisierung-beispiel-2"><a class="header" href="#generalisierung-und-spezialisierung-beispiel-2">Generalisierung und Spezialisierung Beispiel 2</a></h1>
<h2 id="generalisierung"><a class="header" href="#generalisierung">Generalisierung:</a></h2>
<p>PKW, LKW → Fahrzeug</p>
<pre><code class="language-java">//Oberklasse:

abstract class Fahrzeug {
    
    protected String farbe; //protected -&gt; verfügbar in unterklassen

    public Fahrzeug(String farbe) { //Konstruktor der Klasse &quot;Fahrzeug&quot;
        this.farbe = farbe;
    }
}

//Unterklassen:

class LKW extends Fahrzeug {
    
    private double maxGewicht;

    public LKW(String farbe, double maxGewicht) { //Konstruktor der Klasse LKW
        super(farbe); //ruft den Konstruktor der Klasse &quot;Fahrzeug&quot; auf
        this.maxGewicht = maxGewicht;
    }
}

class PKW extends Fahrzeug {

    private int tueren;

    public PKW(String farbe, int tueren) { //Konstruktor der Klasse PKW
        super(farbe); //ruft den Konstruktor der Klasse &quot;Fahrzeug&quot; auf
        this.tueren = tueren;
    }

}
</code></pre>
<h2 id="spezialisierung"><a class="header" href="#spezialisierung">Spezialisierung:</a></h2>
<p>Haus → Schule, Krankenhaus</p>
<pre><code class="language-java">//Oberklasse

abstract class Haus {
    
    protected boolean fenster; //protected -&gt; verfügbar in unterklassen
    
    public Haus(boolean fenster) {
        this.fenster = fenster;
    } 
}

//Unterklassen

class Schule extends Haus {

    private int tueren;

    public Schule(boolean fenster, int tueren) {
        super(fenster);
        this.tueren = tueren;
    }
}

class Krankenhaus extends Haus {

    private int betten;

    public Krankenhaus(boolean fenster, int betten) {
        super(fenster);
        this.betten = betten;
    }
}

</code></pre>
<blockquote>
<p>Beides ist das Gleiche. Spezialisierung kann auch als Generalisierung angesehen werden. Die Implementation ist identisch. <br>Spezialisierung → Eine Klasse, die in mehrere spezialisiert wird.<br>
Generalisierung → mehrere Klassen die in eine vereinfacht/zusammengefasst werden (diese Klasse hat dann die gemeinsamen Attribute und Methoden)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="generalisierung-und-spezialisierung-1"><a class="header" href="#generalisierung-und-spezialisierung-1">Generalisierung und Spezialisierung</a></h2>
<p>Generalisierung → 2 Klassen werden &quot;vereinfacht&quot; und stammen
nun einer Oberklasse ab, die die gemeinsamen Attribute
beinhaltet</p>
<p>Spezialisierung → Eine Oberklasse wird &quot;spezialisiert&quot; mehrere
Unterklassen stammen dieser ab und beinhalten neue Attribute.
Letztendlich ist es eine Frage der Perspektive, Generalisierung
und Spezialisierung werden identisch implementiert und in UML
notiert.</p>
<h2 id="implizite-vererbung"><a class="header" href="#implizite-vererbung">Implizite Vererbung</a></h2>
<p>&quot;vermutende Vererbung&quot; Alle Klassen in Java stammen von anderen
Klassen ab. Auch unwissend. Falls eine Klasse nicht explizit
einer anderen abstammt, stammt sie dem Objekt in Java ab.</p>
<h2 id="explizite-vererbung"><a class="header" href="#explizite-vererbung">Explizite Vererbung</a></h2>
<p>bei der expliziten Vererbung wird genau definiert, wovon die
Klasse abstammt. Dies wird durch den <code>extends</code> Modifizierer getan.</p>
<h2 id="abstrakte-klasse"><a class="header" href="#abstrakte-klasse">Abstrakte Klasse</a></h2>
<p>eine abstrakte Klasse ist eine, die nicht instanziiert werden
kann. Sie wird von anderen Klassen benutzt, die dieser
abstammen. Abstrakte Klassen werden genutzt, um eine Art
Hierarchie von Abstraktion zu schaffen, wobei diese Klasse eine
Art Platzhalter darstellt.</p>
<h2 id="super-methode"><a class="header" href="#super-methode">super() Methode</a></h2>
<p>die <code>super</code> Methode wird benutzt, um den Konstruktor der Oberklasse aufzurufen.
Falls super in einem Konstruktor einer Unterklasse verwendet
wird, muss dies in der ersten Zeile nach der Signatur erfolgen.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="standardwerte"><a class="header" href="#standardwerte">Standardwerte</a></h2>
<p>Verschiedene Typen haben verschiedene Standardwerte, die genutzt werden, wenn man ihnen keinen konkreten Wert zugewiesen hat. Hier eine Tabelle mit den Standardwerten:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Typ</th><th>Standardwert</th></tr></thead><tbody>
<tr><td style="text-align: center">byte</td><td><code>0</code></td></tr>
<tr><td style="text-align: center">short</td><td><code>0</code></td></tr>
<tr><td style="text-align: center">int</td><td><code>0</code></td></tr>
<tr><td style="text-align: center">long</td><td><code>0</code></td></tr>
<tr><td style="text-align: center">float</td><td><code>0.0</code></td></tr>
<tr><td style="text-align: center">double</td><td><code>0.0</code></td></tr>
<tr><td style="text-align: center">boolean</td><td><code>false</code></td></tr>
<tr><td style="text-align: center">char</td><td><code>0</code> (nicht das Zeichen 0)</td></tr>
<tr><td style="text-align: center">Objekt</td><td><code>null</code> (Zeiger auf nichts)</td></tr>
</tbody></table>
</div>
<h2 id="erstellung"><a class="header" href="#erstellung">Erstellung</a></h2>
<p>Ein leeres Array, bei dem der Speicherplatz mit dem Standardwert des Typen initialisiert wird, erstellt man so:</p>
<pre><code class="language-java">Typ[] einArray = new Typ[10];
</code></pre>
<p>Das obere Array hat die Länge 10.
Wenn der Typ zum Beispiel <code>int</code> wäre, hätte jedes Element des Arrays nun den Wert <code>0</code>.</p>
<h3 id="alternative-1"><a class="header" href="#alternative-1">Alternative 1</a></h3>
<p>Alternativ kann man direkt Werte für das zu erstellende Array angeben:</p>
<pre><code class="language-java">einArray = new int[]{1, 2, 3};
</code></pre>
<p>Das obere Array hat die Länge 3.</p>
<h3 id="alternative-2"><a class="header" href="#alternative-2">Alternative 2</a></h3>
<p>Bei der Deklaration einer Variable kann bei <a href="informatik/java/arrays.html#alternative-1">Alternative 1</a> das <code>new Typ[]</code> weggelassen werden:</p>
<pre><code class="language-java">int[] einAnderesArray = {5, 10, 15};
</code></pre>
<p>Das obere Array hat die Länge 3.</p>
<h2 id="länge"><a class="header" href="#länge">Länge</a></h2>
<p>Um im Nachhin ein auf die Länge des Arrays zuzugreifen kann man auf das Attribut <code>length</code> des Arrays zugreifen:</p>
<pre><code class="language-java">int[] einArray = new int[7];
int laenge = einArray.length; // 7
</code></pre>
<p>Die Länge des Arrays kann nicht im Nachhinein verändert werden.</p>
<h2 id="zugriff-auf-elemente"><a class="header" href="#zugriff-auf-elemente">Zugriff auf Elemente</a></h2>
<p>Auf die Elemente des Arrays kann so zugegriffen werden:</p>
<pre><code class="language-java">int[] einArray = new int[]{1, 2, 3};
int erstesElement = einArray[0];
</code></pre>
<p>Das erste Element hat einen Index von <code>0</code>, das zweite einen von <code>1</code>, usw.</p>
<h2 id="veränderung-der-elemente"><a class="header" href="#veränderung-der-elemente">Veränderung der Elemente</a></h2>
<p>Um Elemente in dem Array zu verändern muss bei dem Zugriff ein neuer Wert gesetzt werden:</p>
<pre><code class="language-java">int[] einArray = new int[]{1, 4, 3};
einArray[1] = 2;
</code></pre>
<p><code>einArray</code> enspricht nun <code>{1, 2, 3}</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexikon"><a class="header" href="#lexikon">Lexikon</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
